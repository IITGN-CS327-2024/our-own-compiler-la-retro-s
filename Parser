import ply.lex as lex
import ply.yacc as yacc

# Define tokens
tokens = (
    'TYPEDEF',
    'WORD',
    'EQUALS',
    'SEMICOLON',
    'NUMBER',
    'LPAREN',
    'RPAREN',
    'LCURLY',
    'RCURLY',
    'DISPLAY',
    'QUOTATION',
    'COMMA',
    'INPUT',
    'IF',
    'OTIF',
    'OTW',
    'FOR',
    'WHILE',
    'GET_OUT',
    'GO_ON',
    'TRY',
    'CATCH',
    'FINALLY',
    'TRUE',
    'FALSE',
    'BinaryOperator',
    'ConditionalOperator',
)

# Define token regular expressions
t_EQUALS = r'='
t_SEMICOLON = r';'
t_LPAREN = r'\('
t_RPAREN = r'\)'
t_LCURLY = r'\{'
t_RCURLY = r'\}'
t_DISPLAY = r'display'
t_QUOTATION = r'"'
t_COMMA = r','
t_INPUT = r'input'
t_IF = r'if'
t_OTIF = r'otif'
t_OTW = r'otw'
t_FOR = r'for'
t_WHILE = r'while'
t_GET_OUT = r'get_out'
t_GO_ON = r'go_on'
t_TRY = r'try'
t_CATCH = r'catch'
t_FINALLY = r'finally'
t_TRUE = r'TRUE'
t_FALSE = r'FALSE'
t_BinaryOperator = r'==|!=|<=|>=|\|\||&&|[+\-*/=](?!=)'
t_ConditionalOperator = r'<|>|<=|>=|==|!='

# Define a function for matching WORD tokens
def t_WORD(t):
    r'[a-zA-Z_][a-zA-Z0-9_]*'
    if t.value == 'TRUE' or t.value == 'FALSE':
        t.type = 'BOOL'
    return t

# Define a function for matching NUMBER tokens
def t_NUMBER(t):
    r'\d+'
    t.value = int(t.value)
    return t

# Define a function for handling unknown tokens
def t_error(t):
    print("Illegal character '%s'" % t.value[0])
    t.lexer.skip(1)

# Define lexer flags to ignore whitespace
t_ignore = ' \t'

# Build the lexer
lexer = lex.lex()

# Define parser rules
def p_start(p):
    '''start : typedef start_fn LPAREN RPAREN LCURLY statements RCURLY
             | '''
    if len(p) == 8:
        p[0] = p[6]
    else:
        p[0] = None

def p_typedef(p):
    '''typedef : int
               | bool
               | dotie
               | bigint
               | char'''
    p[0] = p[1]

def p_start_fn(p):
    'start_fn : start'
    p[0] = p[1]

def p_statements(p):
    '''statements : statement SEMICOLON statements
                  | statement SEMICOLON
                  | EMPTY'''
    if len(p) == 4:
        p[0] = [p[1]] + p[3]
    elif len(p) == 3:
        p[0] = [p[1]]
    else:
        p[0] = []

def p_statement(p):
    '''statement : display_statement
                 | input_statement
                 | if_statement
                 | otif_statement
                 | otw_statement
                 | for_loop
                 | while_loop
                 | get_out_statement
                 | go_on_statement
                 | function_definition
                 | exception_handling
                 | expression'''
    p[0] = p[1]

def p_display_statement(p):
    'display_statement : DISPLAY LPAREN display_args RPAREN'
    p[0] = ('display_statement', p[3])

def p_display_args(p):
    '''display_args : expression COMMA display_args
                    | expression
                    | QUOTATION expression QUOTATION'''
    if len(p) == 4:
        p[0] = [p[1]] + p[3]
    elif len(p) == 2:
        p[0] = [p[1]]
    else:
        p[0] = [p[2]]

def p_input_statement(p):
    'input_statement : INPUT LPAREN expression RPAREN'
    p[0] = ('input_statement', p[3])

def p_if_statement(p):
    'if_statement : IF LPAREN expression RPAREN LCURLY statements RCURLY'
    p[0] = ('if_statement', p[3], p[6])

def p_otif_statement(p):
    'otif_statement : OTIF LPAREN expression RPAREN LCURLY statements RCURLY'
    p[0] = ('otif_statement', p[3], p[6])

def p_otw_statement(p):
    'otw_statement : OTW LCURLY statements RCURLY'
    p[0] = ('otw_statement', p[3])

def p_for_loop(p):
    'for_loop : FOR LPAREN for_args RPAREN LCURLY statements RCURLY'
    p[0] = ('for_loop', p[3], p[6])

def p_for_args(p):
    'for_args : expression1 SEMICOLON expression2 SEMICOLON expression3'
    p[0] = (p[1], p[3], p[5])

def p_expression1(p):
    '''expression1 : variable_declaration
                   | variable_assignment'''
    p[0] = p[1]

def p_expression2(p):
    'expression2 : variable_assignment'
    p[0] = p[1]

def p_expression3(p):
    'expression3 : expression ConditionalOperator expression'
    p[0] = (p[1], p[2], p[3])

def p_while_loop(p):
    'while_loop : WHILE LPAREN expression3 RPAREN LCURLY statements RCURLY'
    p[0] = ('while_loop', p[3], p[6])

def p_get_out_statement(p):
    'get_out_statement : GET_OUT'
    p[0] = ('get_out_statement',)

def p_go_on_statement(p):
    'go_on_statement : GO_ON'
    p[0] = ('go_on_statement',)

def p_function_definition(p):
    'function_definition : TYPEDEF WORD LPAREN function_args RPAREN LCURLY statements RCURLY'
    p[0] = ('function_definition', p[2], p[4], p[7])

def p_function_args(p):
    '''function_args : WORD COMMA function_args
                     | WORD'''
    if len(p) == 4:
        p[0] = [p[1]] + p[3]
    else:
        p[0] = [p[1]]

def p_exception_handling(p):
    'exception_handling : TRY LCURLY statements RCURLY CATCH LPAREN WORD RPAREN LCURLY statements RCURLY FINALLY LCURLY statements RCURLY'
    p[0] = ('exception_handling', p[3], p[9], p[13])

def p_expression(p):
    '''expression : number
                  | word
                  | BOOL
                  | variable_declaration
                  | variable_assignment
                  | expression BinaryOperator expression
                  | LPAREN expression RPAREN
                  | function_call'''
    if len(p) == 4:
        p[0] = (p[1], p[2], p[3])
    elif len(p) == 3:
        p[0] = (p[1], p[2])
    else:
        p[0] = p[1]

def p_variable_declaration(p):
    'variable_declaration : typedef WORD EQUALS expression'
    p[0] = ('variable_declaration', p[1], p[2], p[4])

def p_variable_assignment(p):
    'variable_assignment : WORD EQUALS expression'
    p[0] = ('variable_assignment', p[1], p[3])

def p_function_call(p):
    'function_call : WORD LPAREN function_call_args RPAREN'
    p[0] = ('function_call', p[1], p[3])

def p_function_call_args(p):
    '''function_call_args : expression COMMA function_call_args
                          | expression'''
    if len(p) == 4:
        p[0] = [p[1]] + p[3]
    else:
        p[0] = [p[1]]

# Error rule for syntax errors
def p_error(p):
    print("Syntax error in input!")

# Define empty rule
def p_empty(p):
    'EMPTY :'
    pass

# Build the parser
parser = yacc.yacc()

# Test the parser with an example input
input_str = "int start(){int x = 10;}"
parsed_output = parser.parse(input_str, lexer=lexer)
print(parsed_output)
